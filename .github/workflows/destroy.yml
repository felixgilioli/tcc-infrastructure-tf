name: IaC Pipeline - EKS Destroy

on:
  push:
    branches:
      - destroy
  workflow_dispatch:

env:
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  AWS_REGION: ${{ secrets.AWS_REGION }}

jobs:
  terraform-destroy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4.2.2

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.7.0"
          terraform_wrapper: false

      - name: Terraform Init
        run: terraform init
        working-directory: ./src

      # ========== DESCOBRIR VPC_ID E EKS CLUSTER ==========

      - name: üîç Descobrir VPC_ID e EKS Cluster do Terraform State
        id: get_resources
        run: |
          echo "Buscando recursos do Terraform State..."
          
          # Listar recursos
          echo "Listando recursos do state:"
          terraform state list
          
          # ===== VPC =====
          VPC_RESOURCE=$(terraform state list | grep -E 'aws_vpc\.' | head -1)
          
          if [ -z "$VPC_RESOURCE" ]; then
            echo "‚ö†Ô∏è Nenhum recurso aws_vpc encontrado no state"
            VPC_ID=""
          else
            echo "Recurso VPC encontrado: $VPC_RESOURCE"
            VPC_ID=$(terraform state show "$VPC_RESOURCE" 2>/dev/null | grep -E '^\s*id\s*=' | head -1 | sed 's/.*=\s*"\(.*\)"/\1/' | tr -d ' ')
            
            if [[ ! "$VPC_ID" =~ ^vpc-[a-f0-9]+ ]]; then
              VPC_ID=$(terraform show -json 2>/dev/null | jq -r '.values.root_module.resources[]? | select(.type=="aws_vpc") | .values.id' | head -1)
            fi
          fi
          
          echo "VPC_ID=$VPC_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ VPC_ID: $VPC_ID"
          
          # ===== EKS Cluster =====
          EKS_RESOURCE=$(terraform state list | grep -E 'aws_eks_cluster\.' | head -1)
          
          if [ -z "$EKS_RESOURCE" ]; then
            echo "‚ö†Ô∏è Nenhum recurso aws_eks_cluster encontrado no state"
            CLUSTER_NAME=""
          else
            echo "Recurso EKS encontrado: $EKS_RESOURCE"
            CLUSTER_NAME=$(terraform state show "$EKS_RESOURCE" 2>/dev/null | grep -E '^\s*name\s*=' | head -1 | sed 's/.*=\s*"\(.*\)"/\1/' | tr -d ' ')
          fi
          
          echo "CLUSTER_NAME=$CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "‚úÖ CLUSTER_NAME: $CLUSTER_NAME"
        working-directory: ./src

      # ========== LIMPEZA DE RECURSOS EKS ==========

      - name: üî• 0/8 - Deletar Node Groups e Fargate Profiles do EKS
        if: steps.get_resources.outputs.CLUSTER_NAME != ''
        run: |
          CLUSTER_NAME="${{ steps.get_resources.outputs.CLUSTER_NAME }}"
          echo "Deletando recursos do EKS Cluster: $CLUSTER_NAME"
          
          # Deletar Node Groups
          echo "=== Deletando Node Groups ==="
          NODE_GROUPS=$(aws eks list-nodegroups --cluster-name $CLUSTER_NAME --query 'nodegroups[*]' --output text 2>/dev/null || echo "")
          
          if [ -n "$NODE_GROUPS" ] && [ "$NODE_GROUPS" != "None" ]; then
            for ng in $NODE_GROUPS; do
              echo "  ‚ûú Deletando Node Group: $ng"
              aws eks delete-nodegroup --cluster-name $CLUSTER_NAME --nodegroup-name $ng 2>/dev/null || true
            done
            
            echo "Aguardando Node Groups serem deletados (pode levar alguns minutos)..."
            for ng in $NODE_GROUPS; do
              aws eks wait nodegroup-deleted --cluster-name $CLUSTER_NAME --nodegroup-name $ng 2>/dev/null || true
            done
          else
            echo "‚úÖ Nenhum Node Group encontrado"
          fi
          
          # Deletar Fargate Profiles
          echo "=== Deletando Fargate Profiles ==="
          FARGATE_PROFILES=$(aws eks list-fargate-profiles --cluster-name $CLUSTER_NAME --query 'fargateProfileNames[*]' --output text 2>/dev/null || echo "")
          
          if [ -n "$FARGATE_PROFILES" ] && [ "$FARGATE_PROFILES" != "None" ]; then
            for fp in $FARGATE_PROFILES; do
              echo "  ‚ûú Deletando Fargate Profile: $fp"
              aws eks delete-fargate-profile --cluster-name $CLUSTER_NAME --fargate-profile-name $fp 2>/dev/null || true
            done
            
            echo "Aguardando Fargate Profiles serem deletados..."
            for fp in $FARGATE_PROFILES; do
              aws eks wait fargate-profile-deleted --cluster-name $CLUSTER_NAME --fargate-profile-name $fp 2>/dev/null || true
            done
          else
            echo "‚úÖ Nenhum Fargate Profile encontrado"
          fi
        continue-on-error: true

      # ========== LIMPEZA FOR√áADA DE RECURSOS AWS ==========

      - name: üîç Diagn√≥stico - Listar recursos presos
        if: steps.get_resources.outputs.VPC_ID != ''
        run: |
          VPC_ID="${{ steps.get_resources.outputs.VPC_ID }}"
          echo "============================================"
          echo "üìã DIAGN√ìSTICO DE RECURSOS NA VPC: $VPC_ID"
          echo "============================================"
          
          echo -e "\n=== Load Balancers ==="
          aws elbv2 describe-load-balancers \
            --query "LoadBalancers[?VpcId=='$VPC_ID'].[LoadBalancerName,LoadBalancerArn,State.Code]" \
            --output table 2>/dev/null || echo "Nenhum ALB/NLB encontrado"
          
          echo -e "\n=== Classic Load Balancers ==="
          aws elb describe-load-balancers \
            --query "LoadBalancerDescriptions[?VPCId=='$VPC_ID'].[LoadBalancerName]" \
            --output table 2>/dev/null || echo "Nenhum CLB encontrado"
          
          echo -e "\n=== NAT Gateways ==="
          aws ec2 describe-nat-gateways \
            --filter "Name=vpc-id,Values=$VPC_ID" \
            --query 'NatGateways[*].[NatGatewayId,State,SubnetId]' \
            --output table 2>/dev/null || echo "Nenhum NAT encontrado"
          
          echo -e "\n=== VPC Endpoints ==="
          aws ec2 describe-vpc-endpoints \
            --filters "Name=vpc-id,Values=$VPC_ID" \
            --query 'VpcEndpoints[*].[VpcEndpointId,ServiceName,State]' \
            --output table 2>/dev/null || echo "Nenhum VPC Endpoint encontrado"
          
          echo -e "\n=== Internet Gateways ==="
          aws ec2 describe-internet-gateways \
            --filters "Name=attachment.vpc-id,Values=$VPC_ID" \
            --query 'InternetGateways[*].[InternetGatewayId]' \
            --output table 2>/dev/null || echo "Nenhum IGW encontrado"
          
          echo -e "\n=== Elastic IPs ==="
          aws ec2 describe-addresses \
            --filters "Name=domain,Values=vpc" \
            --query 'Addresses[*].[PublicIp,AllocationId,AssociationId]' \
            --output table 2>/dev/null || echo "Nenhum EIP encontrado"
          
          echo -e "\n=== Network Interfaces ==="
          aws ec2 describe-network-interfaces \
            --filters "Name=vpc-id,Values=$VPC_ID" \
            --query 'NetworkInterfaces[*].[NetworkInterfaceId,Status,InterfaceType,Description]' \
            --output table 2>/dev/null || echo "Nenhum ENI encontrado"
          
          echo -e "\n=== Subnets ==="
          aws ec2 describe-subnets \
            --filters "Name=vpc-id,Values=$VPC_ID" \
            --query 'Subnets[*].[SubnetId,CidrBlock,AvailabilityZone]' \
            --output table 2>/dev/null || echo "Nenhuma Subnet encontrada"
        continue-on-error: true

      - name: üî• 1/8 - Deletar Load Balancers (ALB/NLB)
        if: steps.get_resources.outputs.VPC_ID != ''
        run: |
          VPC_ID="${{ steps.get_resources.outputs.VPC_ID }}"
          echo "Deletando Load Balancers da VPC $VPC_ID..."
          
          # ALB/NLB
          LBS=$(aws elbv2 describe-load-balancers \
            --query "LoadBalancers[?VpcId=='$VPC_ID'].LoadBalancerArn" \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$LBS" ] && [ "$LBS" != "None" ]; then
            for lb in $LBS; do
              echo "  ‚ûú Deletando ALB/NLB: $lb"
              
              # Primeiro deletar listeners
              LISTENERS=$(aws elbv2 describe-listeners --load-balancer-arn $lb --query 'Listeners[*].ListenerArn' --output text 2>/dev/null || echo "")
              for listener in $LISTENERS; do
                aws elbv2 delete-listener --listener-arn $listener 2>/dev/null || true
              done
              
              aws elbv2 delete-load-balancer --load-balancer-arn $lb 2>/dev/null || true
            done
            echo "Aguardando LBs serem deletados (60s)..."
            sleep 60
          else
            echo "‚úÖ Nenhum ALB/NLB encontrado"
          fi
          
          # Classic LB
          CLBS=$(aws elb describe-load-balancers \
            --query "LoadBalancerDescriptions[?VPCId=='$VPC_ID'].LoadBalancerName" \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$CLBS" ] && [ "$CLBS" != "None" ]; then
            for clb in $CLBS; do
              echo "  ‚ûú Deletando CLB: $clb"
              aws elb delete-load-balancer --load-balancer-name $clb 2>/dev/null || true
            done
            sleep 30
          else
            echo "‚úÖ Nenhum Classic LB encontrado"
          fi
        continue-on-error: true

      - name: üî• 2/8 - Deletar Target Groups
        if: steps.get_resources.outputs.VPC_ID != ''
        run: |
          VPC_ID="${{ steps.get_resources.outputs.VPC_ID }}"
          echo "Deletando Target Groups da VPC $VPC_ID..."
          
          TGS=$(aws elbv2 describe-target-groups \
            --query "TargetGroups[?VpcId=='$VPC_ID'].TargetGroupArn" \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$TGS" ] && [ "$TGS" != "None" ]; then
            for tg in $TGS; do
              echo "  ‚ûú Deletando Target Group: $tg"
              aws elbv2 delete-target-group --target-group-arn $tg 2>/dev/null || true
            done
          else
            echo "‚úÖ Nenhum Target Group encontrado"
          fi
        continue-on-error: true

      - name: üî• 3/8 - Deletar VPC Endpoints
        if: steps.get_resources.outputs.VPC_ID != ''
        run: |
          VPC_ID="${{ steps.get_resources.outputs.VPC_ID }}"
          echo "Deletando VPC Endpoints da VPC $VPC_ID..."
          
          ENDPOINTS=$(aws ec2 describe-vpc-endpoints \
            --filters "Name=vpc-id,Values=$VPC_ID" \
            --query 'VpcEndpoints[*].VpcEndpointId' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$ENDPOINTS" ] && [ "$ENDPOINTS" != "None" ]; then
            for ep in $ENDPOINTS; do
              echo "  ‚ûú Deletando Endpoint: $ep"
              aws ec2 delete-vpc-endpoints --vpc-endpoint-ids $ep 2>/dev/null || true
            done
            echo "Aguardando VPC Endpoints serem deletados (30s)..."
            sleep 30
          else
            echo "‚úÖ Nenhum VPC Endpoint encontrado"
          fi
        continue-on-error: true

      - name: üî• 4/8 - Deletar NAT Gateways
        if: steps.get_resources.outputs.VPC_ID != ''
        run: |
          VPC_ID="${{ steps.get_resources.outputs.VPC_ID }}"
          echo "Deletando NAT Gateways da VPC $VPC_ID..."
          
          NATS=$(aws ec2 describe-nat-gateways \
            --filter "Name=vpc-id,Values=$VPC_ID" "Name=state,Values=available,pending,deleting" \
            --query 'NatGateways[*].NatGatewayId' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$NATS" ] && [ "$NATS" != "None" ]; then
            for nat in $NATS; do
              echo "  ‚ûú Deletando NAT: $nat"
              aws ec2 delete-nat-gateway --nat-gateway-id $nat 2>/dev/null || true
            done
            
            echo "Aguardando NAT Gateways serem deletados..."
            for nat in $NATS; do
              echo "  ‚è≥ Aguardando $nat..."
              aws ec2 wait nat-gateway-deleted --nat-gateway-ids $nat 2>/dev/null || true
            done
          else
            echo "‚úÖ Nenhum NAT Gateway encontrado"
          fi
        continue-on-error: true

      - name: üî• 5/8 - Liberar Elastic IPs
        run: |
          echo "Liberando Elastic IPs..."
          
          EIPS=$(aws ec2 describe-addresses \
            --filters "Name=domain,Values=vpc" \
            --query 'Addresses[?AssociationId==`null` || AssociationId==``].AllocationId' \
            --output text 2>/dev/null || echo "")
          
          # Tamb√©m pegar EIPs associados
          ALL_EIPS=$(aws ec2 describe-addresses \
            --filters "Name=domain,Values=vpc" \
            --query 'Addresses[*].[AllocationId,AssociationId]' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$ALL_EIPS" ] && [ "$ALL_EIPS" != "None" ]; then
            echo "$ALL_EIPS" | while read -r alloc assoc; do
              if [ -n "$alloc" ] && [ "$alloc" != "None" ]; then
                echo "  ‚ûú Processando EIP: $alloc"
                
                # Desassociar se necess√°rio
                if [ -n "$assoc" ] && [ "$assoc" != "None" ] && [ "$assoc" != "null" ]; then
                  echo "    ‚Ü≥ Desassociando..."
                  aws ec2 disassociate-address --association-id $assoc 2>/dev/null || true
                  sleep 5
                fi
                
                # Liberar
                echo "    ‚Ü≥ Liberando..."
                aws ec2 release-address --allocation-id $alloc 2>/dev/null || true
              fi
            done
          else
            echo "‚úÖ Nenhum Elastic IP encontrado"
          fi
        continue-on-error: true

      - name: üî• 6/8 - Deletar Network Interfaces
        if: steps.get_resources.outputs.VPC_ID != ''
        run: |
          VPC_ID="${{ steps.get_resources.outputs.VPC_ID }}"
          echo "Deletando Network Interfaces da VPC $VPC_ID..."
          
          # Loop m√∫ltiplas vezes porque alguns ENIs podem ficar presos
          for attempt in 1 2 3; do
            echo "=== Tentativa $attempt ==="
            
            ENIS=$(aws ec2 describe-network-interfaces \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'NetworkInterfaces[*].[NetworkInterfaceId,Attachment.AttachmentId,Status]' \
              --output text 2>/dev/null || echo "")
            
            if [ -z "$ENIS" ] || [ "$ENIS" == "None" ]; then
              echo "‚úÖ Nenhum Network Interface restante"
              break
            fi
            
            echo "$ENIS" | while read -r eni attach status; do
              if [ -n "$eni" ] && [ "$eni" != "None" ]; then
                echo "  ‚ûú Processando ENI: $eni (status: $status)"
                
                # Desanexar se necess√°rio
                if [ -n "$attach" ] && [ "$attach" != "None" ] && [ "$attach" != "null" ]; then
                  echo "    ‚Ü≥ Desanexando..."
                  aws ec2 detach-network-interface --attachment-id $attach --force 2>/dev/null || true
                  sleep 10
                fi
                
                # Deletar
                echo "    ‚Ü≥ Deletando..."
                aws ec2 delete-network-interface --network-interface-id $eni 2>/dev/null || true
              fi
            done
            
            sleep 15
          done
        continue-on-error: true

      - name: üî• 7/8 - Deletar Security Groups
        if: steps.get_resources.outputs.VPC_ID != ''
        run: |
          VPC_ID="${{ steps.get_resources.outputs.VPC_ID }}"
          echo "Deletando Security Groups da VPC $VPC_ID..."
          
          # Primeiro, remover todas as regras de ingress/egress que referenciam outros SGs
          SGS=$(aws ec2 describe-security-groups \
            --filters "Name=vpc-id,Values=$VPC_ID" \
            --query 'SecurityGroups[?GroupName!=`default`].GroupId' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$SGS" ] && [ "$SGS" != "None" ]; then
            echo "=== Removendo regras de refer√™ncia entre SGs ==="
            for sg in $SGS; do
              echo "  ‚ûú Limpando regras do SG: $sg"
              
              # Remover regras de ingress
              INGRESS=$(aws ec2 describe-security-groups --group-ids $sg \
                --query 'SecurityGroups[0].IpPermissions' --output json 2>/dev/null || echo "[]")
              if [ "$INGRESS" != "[]" ] && [ "$INGRESS" != "null" ]; then
                aws ec2 revoke-security-group-ingress --group-id $sg --ip-permissions "$INGRESS" 2>/dev/null || true
              fi
              
              # Remover regras de egress
              EGRESS=$(aws ec2 describe-security-groups --group-ids $sg \
                --query 'SecurityGroups[0].IpPermissionsEgress' --output json 2>/dev/null || echo "[]")
              if [ "$EGRESS" != "[]" ] && [ "$EGRESS" != "null" ]; then
                aws ec2 revoke-security-group-egress --group-id $sg --ip-permissions "$EGRESS" 2>/dev/null || true
              fi
            done
            
            sleep 10
            
            echo "=== Deletando Security Groups ==="
            for sg in $SGS; do
              echo "  ‚ûú Deletando SG: $sg"
              aws ec2 delete-security-group --group-id $sg 2>/dev/null || true
            done
          else
            echo "‚úÖ Nenhum Security Group customizado encontrado"
          fi
        continue-on-error: true

      - name: üî• 8/8 - Limpar Internet Gateway e Route Tables
        if: steps.get_resources.outputs.VPC_ID != ''
        run: |
          VPC_ID="${{ steps.get_resources.outputs.VPC_ID }}"
          
          echo "=== Detachando Internet Gateways ==="
          IGWS=$(aws ec2 describe-internet-gateways \
            --filters "Name=attachment.vpc-id,Values=$VPC_ID" \
            --query 'InternetGateways[*].InternetGatewayId' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$IGWS" ] && [ "$IGWS" != "None" ]; then
            for igw in $IGWS; do
              echo "  ‚ûú Detachando IGW: $igw"
              aws ec2 detach-internet-gateway --internet-gateway-id $igw --vpc-id $VPC_ID 2>/dev/null || true
              echo "  ‚ûú Deletando IGW: $igw"
              aws ec2 delete-internet-gateway --internet-gateway-id $igw 2>/dev/null || true
            done
          else
            echo "‚úÖ Nenhum Internet Gateway encontrado"
          fi
          
          echo "=== Deletando Route Tables customizadas ==="
          RTS=$(aws ec2 describe-route-tables \
            --filters "Name=vpc-id,Values=$VPC_ID" \
            --query 'RouteTables[?Associations[?Main==`false`]].RouteTableId' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$RTS" ] && [ "$RTS" != "None" ]; then
            for rt in $RTS; do
              echo "  ‚ûú Processando RT: $rt"
              
              # Desassociar subnets
              ASSOCS=$(aws ec2 describe-route-tables --route-table-ids $rt \
                --query 'RouteTables[0].Associations[?!Main].RouteTableAssociationId' \
                --output text 2>/dev/null || echo "")
              
              for assoc in $ASSOCS; do
                if [ -n "$assoc" ] && [ "$assoc" != "None" ]; then
                  aws ec2 disassociate-route-table --association-id $assoc 2>/dev/null || true
                fi
              done
              
              # Deletar route table
              aws ec2 delete-route-table --route-table-id $rt 2>/dev/null || true
            done
          else
            echo "‚úÖ Nenhuma Route Table customizada encontrada"
          fi
          
          echo "=== Deletando Subnets manualmente (se necess√°rio) ==="
          SUBNETS=$(aws ec2 describe-subnets \
            --filters "Name=vpc-id,Values=$VPC_ID" \
            --query 'Subnets[*].SubnetId' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$SUBNETS" ] && [ "$SUBNETS" != "None" ]; then
            for subnet in $SUBNETS; do
              echo "  ‚ûú Tentando deletar Subnet: $subnet"
              aws ec2 delete-subnet --subnet-id $subnet 2>/dev/null || true
            done
          fi
        continue-on-error: true

      # ========== TERRAFORM DESTROY ==========

      - name: üéØ Terraform Destroy - Tentativa 1
        id: destroy1
        run: |
          terraform destroy -auto-approve -parallelism=5 2>&1 | tee destroy1.log
          exit ${PIPESTATUS[0]}
        working-directory: ./src
        continue-on-error: true

      - name: ‚è≥ Aguardar propaga√ß√£o AWS
        if: steps.destroy1.outcome == 'failure'
        run: |
          echo "Primeira tentativa falhou. Aguardando 90s para propaga√ß√£o..."
          sleep 90

      - name: üîÑ Refresh State e Nova Limpeza
        if: steps.destroy1.outcome == 'failure'
        run: |
          VPC_ID="${{ steps.get_resources.outputs.VPC_ID }}"
          
          echo "=== Refresh do Terraform State ==="
          terraform refresh 2>/dev/null || true
          
          if [ -n "$VPC_ID" ]; then
            echo "=== Limpeza adicional de ENIs ==="
            ENIS=$(aws ec2 describe-network-interfaces \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'NetworkInterfaces[*].NetworkInterfaceId' \
              --output text 2>/dev/null || echo "")
            
            for eni in $ENIS; do
              if [ -n "$eni" ] && [ "$eni" != "None" ]; then
                aws ec2 delete-network-interface --network-interface-id $eni 2>/dev/null || true
              fi
            done
          fi
        working-directory: ./src
        continue-on-error: true

      - name: üéØ Terraform Destroy - Tentativa 2
        id: destroy2
        if: steps.destroy1.outcome == 'failure'
        run: terraform destroy -auto-approve -parallelism=1
        working-directory: ./src
        continue-on-error: true

      - name: üéØ Terraform Destroy - Tentativa 3 (For√ßada)
        if: steps.destroy2.outcome == 'failure'
        run: |
          echo "=== Tentativa final com refresh ==="
          terraform refresh || true
          terraform destroy -auto-approve -parallelism=1 -refresh=false
        working-directory: ./src

      - name: ‚úÖ Verifica√ß√£o Final
        if: always()
        run: |
          VPC_ID="${{ steps.get_resources.outputs.VPC_ID }}"
          
          echo "============================================"
          echo "üìã VERIFICA√á√ÉO FINAL DE RECURSOS"
          echo "============================================"
          
          if [ -n "$VPC_ID" ]; then
            echo -e "\n=== Recursos restantes na VPC $VPC_ID ==="
            
            REMAINING=$(aws ec2 describe-subnets \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'Subnets[*].SubnetId' \
              --output text 2>/dev/null || echo "")
            
            if [ -n "$REMAINING" ] && [ "$REMAINING" != "None" ]; then
              echo "‚ö†Ô∏è AVISO: Ainda existem subnets na VPC!"
              aws ec2 describe-subnets \
                --filters "Name=vpc-id,Values=$VPC_ID" \
                --query 'Subnets[*].[SubnetId,CidrBlock]' \
                --output table
            else
              echo "‚úÖ Nenhuma subnet restante"
            fi
            
            VPC_EXISTS=$(aws ec2 describe-vpcs --vpc-ids $VPC_ID 2>/dev/null || echo "")
            if [ -n "$VPC_EXISTS" ]; then
              echo "‚ö†Ô∏è VPC $VPC_ID ainda existe"
            else
              echo "‚úÖ VPC deletada com sucesso"
            fi
          fi
          
          echo -e "\n============================================"
          echo "üèÅ PROCESSO DE DESTROY FINALIZADO"
          echo "============================================"
